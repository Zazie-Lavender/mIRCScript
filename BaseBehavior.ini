[script]
n0=;;Here we just redirect /notices to the active window and handle special cases like ##werewolf's where we want bot notices to also be added 
n1=;;to a window
n2=#noticehandler on
n3=on ^*:notice:*:?: { 
n4=  if ($nick iswm *serv) { haltdef }
n5=  if (SVS isin $level($address($nick,2))) { haltdef }
n6=  echo -a --> < $+ $nick $+ > $1-
n7=  if ($nick == lykos) { /wn <lykos> $1- }
n8=}
n9=
n10=on ^*:text:*:?:{ 
n11=  if ($nick == %safenick) { aline -p @safepm $nick > $1- }
n12=}
n13=#noticehandler end
n14=
n15=;; % [ $+ [ $# ] ] (for appending together variables)
n16=;;This is where we handle raw IRC numerics and route them appropriately. For example we want to suppress certain events and keep them from spamming
n17=;;the server windows with extra information we don't really need.
n18=#rawhandlers on
n19=;;Cache the version reply so we can match against it later and define script behaviors based on ircd behavior by matching against
n20=;;the server's own version reply as some servers may reply differently or have different behaviors for commands.
n21=raw 005:*: {
n22=  set % [ $+ [ $network ] ] % [ $+ [ $network ] ] $1- 
n23=}
n24=;;stop NAMES spamming the server window...we're also caching it in a hashtable as well so we can search against it later.
n25=;;on ^*:join:#: { names $chan } ;;update names list on join
n26=raw 353:*: { 
n27=  ;;echo -s $1-
n28=  hinc -m [ $+($cid,.,$3) ] i
n29=  hadd -m [ $+($cid,.,$3) ] [ NameBuffer $+ [ $hget($+($cid,.,$3),i) ] ] $4-
n30=  haltdef
n31=}
n32=raw 366:*: {
n33=  haltdef 
n34=}
n35=
n36=;;Ping times to server.
n37=on *:connect: { timer 0 60 /tickping }
n38=on *:PONG: { 
n39=  if ($1 == $server) {
n40=    echo -s RTT(Ticks): $calc($ticks - $2) RTT(Sec): $calc($calc($ticks - $2) / 1000) 
n41=    set [ %lag $+ [ $network ] ] $calc($calc($ticks - $2) / 1000)
n42=    haltdef
n43=  }
n44=}
n45=
n46=;;Better Error handling, so we know when we accidentally send a command the server doesn't understand. 
n47=;;We may also try to shoehorn in some sort of lagtime measurements here, but I don't see why we should as /ping and server's pong works too
n48=raw 421:*: { 
n49=  echo -a ( Server ) 421: $2 $+ : $3-
n50=  haltdef
n51=}
n52=
n53=;;caching names data
n54=alias nametable {
n55=  var %i $hget($+($cid,.,$$1),i)
n56=  while (%i > 0) {
n57=    echo -a $$1 > $+(#,%i) > $+(NameBuffer,%i) > $hget($+($cid,.,$$1),$+(NameBuffer,%i))
n58=    dec %i
n59=  }
n60=}
n61=
n62=alias ntn {
n63=  if (isid) { 
n64=    return $hget($+($cid,.,$$1),$+(NameBuffer,$$2)) 
n65=    halt
n66=  }
n67=  echo -a $$1 > $$2 > $+(NameBuffer,$$2) > $hget($+($cid,.,$$1),$+(NameBuffer,$$2))
n68=}
n69=#rawhandlers end
n70=
n71=
n72=;; Smarter handling of sticky channels. We tell the client to send /detach for stuck chans. This gets us *out* of the channel quietly.
n73=;; Obviously, if you stick a channel; it must be added to %sticky so we know which channels to behave this way too. We may actually 
n74=;; need to add a bouncer detection too; but this can come later and we can just copy %sticky to %oldsticky and unset %sticky if we're connecting 
n75=;; directly instead of with the bouncer like normal. or we could just use a group. 
n76=
n77=#ZNCTweaks on
n78=alias part {
n79=  if ($1 isin %sticky) {
n80=    /detach $1
n81=  }
n82=  else { part $1- }
n83=}
n84=
n85=on me:ctcpreply:ZNC*: {
n86=  echo -a reply > $1-
n87=  if ($1) {
n88=    echo -a ZNC Detected!
n89=  }
n90=}
n91=#ZNCTweaks end
n92=
n93=#MassCommands on
n94=alias d {
n95=  detach $$1
n96=  var %i = $wildtok($1-,*,0,32)
n97=  while (%i > 1) {
n98=    detach [ [ $+($$,%i) ] ]
n99=    dec %i
n100=  }
n101=}
n102=
n103=alias j {
n104=  join $$1
n105=  var %i = $wildtok($1-,*,0,32)
n106=  while (%i > 1) {
n107=    join [ [ $+($$,%i) ] ]
n108=    dec %i
n109=  }
n110=}
n111=
n112=alias mv {
n113=  mode $chan $+(+,$str(v,4)) $$1-4
n114=  var %i = $wildtok($1-,*,0,32)
n115=  while (%i > 4) {
n116=    mode $chan +v [ [ $+($$,%i,-,$calc(%i-4)) ] ] 
n117=    dec %i
n118=  }
n119=}
n120=
n121=alias mdv {
n122=  mode $chan $+(-,$str(v,4)) $$1-4
n123=  var %i = $wildtok($1-,*,0,32)
n124=  while (%i > 4) {
n125=    mode $chan -v [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n126=    dec %i
n127=  }
n128=}
n129=
n130=alias m+y {
n131=  mode $chan $+(+,$str(y,4)) $$1-4
n132=  var %i = $wildtok($1-,*,0,32)
n133=  while (%i > 4) {
n134=    mode $chan +y [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n135=    dec %i
n136=  }
n137=}
n138=
n139=alias m-y {
n140=  mode $chan $+(-,$str(y,4)) $$1-4
n141=  var %i = $wildtok($1-,*,0,32)
n142=  while (%i > 4) {
n143=    mode $chan -y [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n144=    dec %i
n145=  }
n146=}
n147=
n148=alias mq {
n149=  mode $chan $+(+,$str(q,4)) $$1-4
n150=  var %i = $wildtok($1-,*,0,32)
n151=  while (%i > 4) {
n152=    mode $chan +q [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n153=    dec %i
n154=  }
n155=}
n156=
n157=alias mdq {
n158=  mode $chan $+(-,$str(q,4)) $$1-4
n159=  var %i = $wildtok($1-,*,0,32)
n160=  while (%i > 4) {
n161=    mode $chan -q [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n162=    dec %i
n163=  }
n164=}
n165=
n166=alias ma {
n167=  mode $chan $+(+,$str(a,4)) $$1-4
n168=  var %i = $wildtok($1-,*,0,32)
n169=  while (%i > 4) {
n170=    mode $chan +a [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n171=    dec %i
n172=  }
n173=}
n174=
n175=alias mda {
n176=  mode $chan $+(-,$str(a,4)) $$1-4
n177=  var %i = $wildtok($1-,*,0,32)
n178=  while (%i > 4) {
n179=    mode $chan -a [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n180=    dec %i
n181=  }
n182=}
n183=
n184=alias mo {
n185=  mode $chan $+(+,$str(o,4)) $$1-4
n186=  var %i = $wildtok($1-,*,0,32)
n187=  while (%i > 4) {
n188=    mode $chan +o [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n189=    dec %i
n190=  }
n191=}
n192=
n193=alias mdo {
n194=  mode $chan $+(-,$str(o,4)) $$1-4
n195=  var %i = $wildtok($1-,*,0,32)
n196=  while (%i > 4) {
n197=    mode $chan -o [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n198=    dec %i
n199=  }
n200=}
n201=
n202=alias mh {
n203=  mode $chan $+(+,$str(h,4)) $$1-4
n204=  var %i = $wildtok($1-,*,0,32)
n205=  while (%i > 4) {
n206=    mode $chan +h [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n207=    dec %i
n208=  }
n209=}
n210=
n211=alias mdq {
n212=  mode $chan $+(-,$str(h,4)) $$1-4
n213=  var %i = $wildtok($1-,*,0,32)
n214=  while (%i > 4) {
n215=    mode $chan -h [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n216=    dec %i
n217=  }
n218=}
n219=
n220=alias mm {
n221=  var %i = $wildtok($2-,*,0,32)
n222=  while (%i > 1) {
n223=    mode $chan [ $+(+,$1) ] [ [ $+($$,%i) ] ]
n224=    dec %i
n225=  }
n226=}
n227=
n228=alias mdm {
n229=  var %i = $wildtok($1-,*,0,32)
n230=  while (%i > 1) {
n231=    mode $chan [ $+(-,$1) ] [ [ $+($$,%i) ] ]
n232=    dec %i
n233=  }
n234=}
n235=#MassCommands end
n236=
n237=#Notifyfix on
n238=alias monitor {
n239=  if ($network isin %nomon) {
n240=    watch $1-
n241=  }
n242=  else { monitor $1- }
n243=}
n244=
n245=#Notifyfix end
n246=
n247=#umodeghandler on
n248=;;Auto-accept users on voice in ##werewolf. 
n249=on ^*:voice:##werewolf: {
n250=  if ($vnick isin [ % $+ [ $network $+ . $+ accept ] ]) { halt }
n251=  /accept $vnick 
n252=  /accept *
n253=}
n254=;;Opers have auto /accept
n255=on ^*:voice:#freenode: {
n256=  if ($vnick isin [ % $+ [ $network $+ . $+ accept ] ]) { halt }
n257=  /accept $vnick 
n258=  /accept *
n259=}
n260=;;Freenode won't track nick changes for accept lists.
n261=on ^*:nick: { 
n262=  if ($newnick isin [ % $+ [ $network $+ . $+ accept ] ]) { halt }
n263=  if ($newnick isvoice ##werewolf) { /accept $newnick | /accept * }
n264=  if ($newnick isvoice #freenode) { /accept $newnick | /accept * }
n265=}
n266=raw 718:*: {
n267=  if ($2 ischan) { /accept $2 | /accept * }
n268=}
n269=raw 281:*: { set [ % $+ [ $network $+ . $+ accept ] ] $2- }
n270=#umodeghandler end
