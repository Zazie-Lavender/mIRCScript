[script]
n0=#ProcessPriority on
n1=;Here is where we simply ask the OS to give us a little bit more processing power
n2=;This is to ensure better stability. This is optional and you may prevent it by typing 
n3=;'/disable #ProcessPriority'. You may also change the priority below to your desired level
n4=;to set performance levels to suit your computing situations.
n5=on *:start {
n6=  run wmic process where name="mirc.exe" CALL setpriority "above normal"
n7=}
n8=#ProcessPriority end
n9=
n10=;;Here we just redirect /notices to the active window and handle special cases like ##werewolf's where we want bot notices to also be added 
n11=;;to a window
n12=#noticehandler on
n13=on ^SVS:notice:*:?: { 
n14=  window -Die2k0 @Services 
n15=  aline -p @Services < $network $+ : $+ $nick > $1-
n16=  echo -s --> < $+ $nick $+ > $1-
n17=  haltdef
n18=}
n19=on ^1:notice:*:?: { 
n20=  ;if (serv isin $nick) { halt }
n21=  if ($active == @Services) { 
n22=    goto noact
n23=  }
n24=  echo -a --> < $+ $nick $+ > $1-
n25=  :noact
n26=  if ($nick == lykos) { /wn <lykos> $1- }
n27=  haltdef
n28=}
n29=
n30=on ^*:text:*:?:{ 
n31=  if ($nick == %safenick) { aline -p @safepm $nick > $1- }
n32=}
n33=on ^*:SNOTICE:*: { 
n34=  if ($window(@snotices) != @snotices) { window -Dk1l25e2 @snotices }
n35=  if (NICK isincs $2) {
n36=    var %c = $r(2,13)
n37=    aline -p %c @snotices $timestamp $+(<,$network,>) $2-
n38=    aline -lpn %c @snotices $4
n39=    aline -lpn %c @snotices $9
n40=    halt
n41=  }
n42=  aline -p @snotices $timestamp $1-
n43=  echo -s > $1-
n44=  if (OPER isincs $2) {
n45=    aline -lpn @snotices $+(!,$3)
n46=  }
n47=  haltdef
n48=}
n49=;; aline -lpn @snotices $2
n50=#noticehandler end
n51=
n52=;; % [ $+ [ $# ] ] (for appending together variables)
n53=;;This is where we handle raw IRC numerics and route them appropriately. For example we want to suppress certain events and keep them from spamming
n54=;;the server windows with extra information we don't really need.
n55=#rawhandlers on
n56=;;Cache the version reply so we can match against it later and define script behaviors based on ircd behavior by matching against
n57=;;the server's own version reply as some servers may reply differently or have different behaviors for commands.
n58=raw 005:*: {
n59=  set % [ $+ [ $network ] ] % [ $+ [ $network ] ] $1- 
n60=}
n61=;;stop NAMES spamming the server window...we're also caching it in a hashtable as well so we can search against it later.
n62=;;on ^*:join:#: { names $chan } ;;update names list on join
n63=raw 353:*: { 
n64=  ;;echo -s $1-
n65=  hinc -m [ $+($cid,.,$3) ] i
n66=  hadd -m [ $+($cid,.,$3) ] [ NameBuffer $+ [ $hget($+($cid,.,$3),i) ] ] $4-
n67=  haltdef
n68=}
n69=raw 366:*: {
n70=  haltdef 
n71=}
n72=
n73=;;Ping times to server.
n74=on *:connect: { 
n75=  timer 0 60 /tickping 
n76=  window -k2l20 $+(@lag,$network)
n77=}
n78=on ^*:PONG: { 
n79=  if ($1 == $server) {
n80=    aline -p $+(@lag,$network) $timestamp RTT(Ticks): $calc($ticks - $2) RTT(Sec): $calc($calc($ticks - $2) / 1000) 
n81=    aline -lp $+(@lag,$network) $timestamp $calc($calc($ticks - $2) / 1000)
n82=    set [ %lag $+ [ $network ] ] $calc($calc($ticks - $2) / 1000)
n83=  }
n84=  haltdef
n85=}
n86=
n87=
n88=;;Better Error handling, so we know when we accidentally send a command the server doesn't understand. 
n89=;;We may also try to shoehorn in some sort of lagtime measurements here, but I don't see why we should as /ping and server's pong works too
n90=raw 421:*: { 
n91=  echo -a ( Server ) 421: $2 $+ : $3-
n92=  haltdef
n93=}
n94=
n95=;;caching names data
n96=alias nametable {
n97=  var %i $hget($+($cid,.,$$1),i)
n98=  while (%i > 0) {
n99=    echo -a $$1 > $+(#,%i) > $+(NameBuffer,%i) > $hget($+($cid,.,$$1),$+(NameBuffer,%i))
n100=    dec %i
n101=  }
n102=}
n103=
n104=alias ntn {
n105=  if (isid) { 
n106=    return $hget($+($cid,.,$$1),$+(NameBuffer,$$2)) 
n107=    halt
n108=  }
n109=  echo -a $$1 > $$2 > $+(NameBuffer,$$2) > $hget($+($cid,.,$$1),$+(NameBuffer,$$2))
n110=}
n111=#rawhandlers end
n112=
n113=
n114=;; Smarter handling of sticky channels. We tell the client to send /detach for stuck chans. This gets us *out* of the channel quietly.
n115=;; Obviously, if you stick a channel; it must be added to %sticky so we know which channels to behave this way too. We may actually 
n116=;; need to add a bouncer detection too; but this can come later and we can just copy %sticky to %oldsticky and unset %sticky if we're connecting 
n117=;; directly instead of with the bouncer like normal. or we could just use a group. 
n118=
n119=#ZNCTweaks on
n120=alias part {
n121=  if ($1 isin %sticky) {
n122=    /detach $1
n123=  }
n124=  else { part $1- }
n125=}
n126=
n127=on me:ctcpreply:ZNC*: {
n128=  echo -a reply > $1-
n129=  if ($1) {
n130=    echo -a ZNC Detected!
n131=  }
n132=}
n133=#ZNCTweaks end
n134=
n135=#MassCommands on
n136=alias d {
n137=  detach $$1
n138=  var %i = $wildtok($1-,*,0,32)
n139=  while (%i > 1) {
n140=    detach [ [ $+($$,%i) ] ]
n141=    dec %i
n142=  }
n143=}
n144=
n145=alias j {
n146=  join $$1
n147=  var %i = $wildtok($1-,*,0,32)
n148=  while (%i > 1) {
n149=    join [ [ $+($$,%i) ] ]
n150=    dec %i
n151=  }
n152=}
n153=
n154=alias mv {
n155=  mode $chan $+(+,$str(v,4)) $$1-4
n156=  var %i = $wildtok($1-,*,0,32)
n157=  while (%i > 4) {
n158=    mode $chan +v [ [ $+($$,%i,-,$calc(%i-4)) ] ] 
n159=    dec %i
n160=  }
n161=}
n162=
n163=alias mdv {
n164=  mode $chan $+(-,$str(v,4)) $$1-4
n165=  var %i = $wildtok($1-,*,0,32)
n166=  while (%i > 4) {
n167=    mode $chan -v [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n168=    dec %i
n169=  }
n170=}
n171=
n172=alias m+y {
n173=  mode $chan $+(+,$str(y,4)) $$1-4
n174=  var %i = $wildtok($1-,*,0,32)
n175=  while (%i > 4) {
n176=    mode $chan +y [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n177=    dec %i
n178=  }
n179=}
n180=
n181=alias m-y {
n182=  mode $chan $+(-,$str(y,4)) $$1-4
n183=  var %i = $wildtok($1-,*,0,32)
n184=  while (%i > 4) {
n185=    mode $chan -y [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n186=    dec %i
n187=  }
n188=}
n189=
n190=alias mq {
n191=  mode $chan $+(+,$str(q,4)) $$1-4
n192=  var %i = $wildtok($1-,*,0,32)
n193=  while (%i > 4) {
n194=    mode $chan +q [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n195=    dec %i
n196=  }
n197=}
n198=
n199=alias mdq {
n200=  mode $chan $+(-,$str(q,4)) $$1-4
n201=  var %i = $wildtok($1-,*,0,32)
n202=  while (%i > 4) {
n203=    mode $chan -q [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n204=    dec %i
n205=  }
n206=}
n207=
n208=alias ma {
n209=  mode $chan $+(+,$str(a,4)) $$1-4
n210=  var %i = $wildtok($1-,*,0,32)
n211=  while (%i > 4) {
n212=    mode $chan +a [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n213=    dec %i
n214=  }
n215=}
n216=
n217=alias mda {
n218=  mode $chan $+(-,$str(a,4)) $$1-4
n219=  var %i = $wildtok($1-,*,0,32)
n220=  while (%i > 4) {
n221=    mode $chan -a [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n222=    dec %i
n223=  }
n224=}
n225=
n226=alias mo {
n227=  mode $chan $+(+,$str(o,4)) $$1-4
n228=  var %i = $wildtok($1-,*,0,32)
n229=  while (%i > 4) {
n230=    mode $chan +o [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n231=    dec %i
n232=  }
n233=}
n234=
n235=alias mdo {
n236=  mode $chan $+(-,$str(o,4)) $$1-4
n237=  var %i = $wildtok($1-,*,0,32)
n238=  while (%i > 4) {
n239=    mode $chan -o [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n240=    dec %i
n241=  }
n242=}
n243=
n244=alias mh {
n245=  mode $chan $+(+,$str(h,4)) $$1-4
n246=  var %i = $wildtok($1-,*,0,32)
n247=  while (%i > 4) {
n248=    mode $chan +h [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n249=    dec %i
n250=  }
n251=}
n252=
n253=alias mdq {
n254=  mode $chan $+(-,$str(h,4)) $$1-4
n255=  var %i = $wildtok($1-,*,0,32)
n256=  while (%i > 4) {
n257=    mode $chan -h [ [ $+($$,%i,-,$calc(%i-4)) ] ]
n258=    dec %i
n259=  }
n260=}
n261=
n262=alias mm {
n263=  var %i = $wildtok($2-,*,0,32)
n264=  while (%i > 1) {
n265=    mode $chan [ $+(+,$1) ] [ [ $+($$,%i) ] ]
n266=    dec %i
n267=  }
n268=}
n269=
n270=alias mdm {
n271=  var %i = $wildtok($1-,*,0,32)
n272=  while (%i > 1) {
n273=    mode $chan [ $+(-,$1) ] [ [ $+($$,%i) ] ]
n274=    dec %i
n275=  }
n276=}
n277=#MassCommands end
n278=
n279=#Notifyfix on
n280=alias monitor {
n281=  if ($network isin %nomon) {
n282=    watch $1-
n283=  }
n284=  else { monitor $1- }
n285=}
n286=
n287=#Notifyfix end
n288=
n289=#umodeghandler on
n290=;;Auto-accept users on voice in ##werewolf. 
n291=on ^*:voice:##werewolf: {
n292=  if ($vnick isin [ % $+ [ $network $+ . $+ accept ] ]) { halt }
n293=  /accept $vnick 
n294=  /accept *
n295=}
n296=;;Opers have auto /accept
n297=on ^*:voice:#freenode: {
n298=  if ($vnick isin [ % $+ [ $network $+ . $+ accept ] ]) { halt }
n299=  /accept $vnick 
n300=  /accept *
n301=}
n302=;;Freenode won't track nick changes for accept lists.
n303=on ^*:nick: { 
n304=  if ($newnick isin [ % $+ [ $network $+ . $+ accept ] ]) { halt }
n305=  if ($newnick isvoice ##werewolf) { /accept $newnick | /accept * }
n306=  if ($newnick isvoice #freenode) { /accept $newnick | /accept * }
n307=}
n308=raw 718:*: {
n309=  if ($2 ischan) { /accept $2 | /accept * }
n310=}
n311=raw 281:*: { set [ % $+ [ $network $+ . $+ accept ] ] $2- }
n312=#umodeghandler end
n313=
n314=#quietmodehandler on
n315=raw 728:*: { echo 7 $2 $+(+,$3) $4 by $5 on $asctime($6,mm/dd/yy @ hh:nn:sst) }
n316=raw 729:*: { echo 7 $2 $3- }
n317=#quietmodehandler end
