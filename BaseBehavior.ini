[script]
n0=;;Here we just redirect /notices to the active window and handle special cases like ##werewolf's where we want bot notices to also be added 
n1=;;to a window
n2=#noticehandler on
n3=on ^*:notice:*:?: { 
n4=  if ($nick iswm *serv) { haltdef }
n5=  if (SVS isin $level($address($nick,2))) { haltdef }
n6=  echo -a --> < $+ $nick $+ > $1-
n7=  if ($nick == lykos) { /wn <lykos> $1- }
n8=}
n9=
n10=on ^*:text:*:?:{ 
n11=  if ($nick == %safenick) { aline -p @safepm $nick > $1- }
n12=}
n13=#noticehandler end
n14=
n15=;; % [ $+ [ $# ] ] (for appending together variables)
n16=;;This is where we handle raw IRC numerics and route them appropriately. For example we want to suppress certain events and keep them from spamming
n17=;;the server windows with extra information we don't really need.
n18=#rawhandlers on
n19=;;Cache the version reply so we can match against it later and define script behaviors based on ircd behavior by matching against
n20=;;the server's own version reply as some servers may reply differently or have different behaviors for commands.
n21=raw 005:*: {
n22=  set % [ $+ [ $network ] ] % [ $+ [ $network ] ] $1- 
n23=}
n24=;;stop NAMES spamming the server window...we're also caching it in a hashtable as well so we can search against it later.
n25=;;on ^*:join:#: { names $chan } ;;update names list on join
n26=raw 353:*: { 
n27=  ;;echo -s $1-
n28=  hinc -m [ $+($cid,.,$3) ] i
n29=  hadd -m [ $+($cid,.,$3) ] [ NameBuffer $+ [ $hget($+($cid,.,$3),i) ] ] $4-
n30=  haltdef
n31=}
n32=raw 366:*: {
n33=  haltdef 
n34=}
n35=
n36=;;Ping times to server.
n37=on *:connect: { timer 0 60 /tickping }
n38=on *:PONG: { 
n39=  if ($1 == $server) {
n40=    echo -s RTT(Ticks): $calc($ticks - $2) RTT(Sec): $calc($calc($ticks - $2) / 1000) 
n41=    set [ %lag $+ [ $network ] ] $calc($calc($ticks - $2) / 1000)
n42=    haltdef
n43=  }
n44=}
n45=
n46=;;Better Error handling, so we know when we accidentally send a command the server doesn't understand. 
n47=;;We may also try to shoehorn in some sort of lagtime measurements here, but I don't see why we should as /ping and server's pong works too
n48=raw 421:*: { 
n49=  echo -a ( Server ) 421: $2 $+ : $3-
n50=  haltdef
n51=}
n52=
n53=;;caching names data
n54=alias nametable {
n55=  var %i $hget($+($cid,.,$$1),i)
n56=  while (%i > 0) {
n57=    echo -a $$1 > $+(#,%i) > $+(NameBuffer,%i) > $hget($+($cid,.,$$1),$+(NameBuffer,%i))
n58=    dec %i
n59=  }
n60=}
n61=
n62=alias ntn {
n63=  if (isid) { 
n64=    return $hget($+($cid,.,$$1),$+(NameBuffer,$$2)) 
n65=    halt
n66=  }
n67=  echo -a $$1 > $$2 > $+(NameBuffer,$$2) > $hget($+($cid,.,$$1),$+(NameBuffer,$$2))
n68=}
n69=#rawhandlers end
n70=
n71=
n72=;; Smarter handling of sticky channels. We tell the client to send /detach for stuck chans. This gets us *out* of the channel quietly.
n73=;; Obviously, if you stick a channel; it must be added to %sticky so we know which channels to behave this way too. We may actually 
n74=;; need to add a bouncer detection too; but this can come later and we can just copy %sticky to %oldsticky and unset %sticky if we're connecting 
n75=;; directly instead of with the bouncer like normal. or we could just use a group. 
n76=
n77=#ZNCTweaks on
n78=alias part {
n79=  if ($1 isin %sticky) {
n80=    /detach $1
n81=  }
n82=  else { part $1- }
n83=}
n84=
n85=on me:ctcpreply:ZNC*: {
n86=  echo -a reply > $1-
n87=  if ($1) {
n88=    echo -a ZNC Detected!
n89=  }
n90=}
n91=
n92=alias d {
n93=  detach $$1
n94=  var %i = $wildtok($1-,*,0,32)
n95=  while (%i > 1) {
n96=    detach [ [ $+($$,%i) ] ]
n97=    dec %i
n98=  }
n99=}
n100=
n101=alias j {
n102=  join $$1
n103=  var %i = $wildtok($1-,*,0,32)
n104=  while (%i > 1) {
n105=    join [ [ $+($$,%i) ] ]
n106=    dec %i
n107=  }
n108=}
n109=
n110=#ZNCTweaks end
n111=
n112=#Notifyfix on
n113=alias monitor {
n114=  if ($network isin %nomon) {
n115=    watch $1-
n116=  }
n117=  else { monitor $1- }
n118=}
n119=
n120=#Notifyfix end
n121=
n122=#umodeghandler on
n123=;;Auto-accept users on voice in ##werewolf. 
n124=on ^*:voice:##werewolf: {
n125=  if ($vnick isin [ % $+ [ $network $+ . $+ accept ] ]) { halt }
n126=  /accept $vnick 
n127=  /accept *
n128=}
n129=;;Opers have auto /accept
n130=on ^*:voice:#freenode: {
n131=  if ($vnick isin [ % $+ [ $network $+ . $+ accept ] ]) { halt }
n132=  /accept $vnick 
n133=  /accept *
n134=}
n135=;;Freenode won't track nick changes for accept lists.
n136=on ^*:nick: { 
n137=  if ($newnick isin [ % $+ [ $network $+ . $+ accept ] ]) { halt }
n138=  if ($newnick isvoice ##werewolf) { /accept $newnick | /accept * }
n139=  if ($newnick isvoice #freenode) { /accept $newnick | /accept * }
n140=}
n141=raw 718:*: {
n142=  if ($2 ischan) { /accept $2 | /accept * }
n143=}
n144=raw 281:*: { set [ % $+ [ $network $+ . $+ accept ] ] $2- }
n145=#umodeghandler end
